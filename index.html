<!DOCTYPE html>
<html lang="zh-Hant-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cat Can Rescue | Queen Meow çš„æ•‘æ´ä½œæˆ°</title>
    <style>
        :root {
            --primary-color: #00d2ff; /* Tech Blue */
            --secondary-color: #2c3e50; /* Dark Metal */
            --text-color: #2c3e50;
            --ui-bg: rgba(255, 255, 255, 0.95);
            --gold-color: #FFD700;
            --accent-color: #ff0055; /* Tech Red */
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #87CEEB;
            touch-action: none;
            user-select: none;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100vh;
        }

        /* UI Layers */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        .interactive {
            pointer-events: auto;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            color: var(--text-color);
            font-weight: bold;
            text-shadow: 1px 1px 0px #fff;
            z-index: 5;
        }

        .hud-box {
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 15px;
            border-radius: 5px; /* More angular for tech feel */
            border-left: 4px solid var(--primary-color);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 5px;
            font-size: 14px;
            pointer-events: auto;
            display: flex;
            align-items: center;
        }

        .money-text {
            color: #d84315;
            font-weight: 800;
            margin-left: 5px;
        }

        .menu-btn {
            cursor: pointer;
            background: #fff;
            border: 2px solid #2c3e50;
            color: #333;
            padding: 5px 10px;
            font-size: 12px;
            border-radius: 4px;
            margin-right: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .menu-btn:hover { background: #eee; }

        /* Skill Indicator */
        #skill-indicator {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 210, 255, 0.8);
            color: white;
            padding: 10px 30px;
            border-radius: 2px;
            font-weight: bold;
            font-size: 1.2em;
            border: 2px solid white;
            box-shadow: 0 0 15px var(--primary-color);
            animation: pulse 1s infinite;
            display: none;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        @keyframes pulse {
            0% { transform: translateX(-50%) scale(1); box-shadow: 0 0 10px var(--primary-color); }
            50% { transform: translateX(-50%) scale(1.05); box-shadow: 0 0 20px var(--primary-color); }
            100% { transform: translateX(-50%) scale(1); box-shadow: 0 0 10px var(--primary-color); }
        }

        /* Panels */
        .panel {
            background: var(--ui-bg);
            padding: 25px;
            border-radius: 10px; /* Less rounded */
            text-align: center;
            box-shadow: 0 15px 40px rgba(0,0,0,0.4);
            border: 2px solid var(--primary-color);
            max-width: 95%;
            width: 500px;
            animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            max-height: 90vh;
            overflow-y: auto;
            pointer-events: auto;
        }

        h1 { margin: 0 0 5px 0; color: #2980b9; font-size: 1.8em; text-transform: uppercase; letter-spacing: 1px; }
        h2 { margin: 0 0 10px 0; color: #e67e22; font-size: 1.4em; }
        p { color: var(--text-color); line-height: 1.4; margin-bottom: 10px; font-size: 0.9em; }
        
        button {
            background: linear-gradient(to right, #2980b9, #2c3e50);
            border: none;
            padding: 12px 25px;
            color: white;
            font-size: 1em;
            border-radius: 4px;
            cursor: pointer;
            margin: 8px 5px;
            box-shadow: 0 4px 0 #1a252f;
            transition: transform 0.1s;
            min-width: 140px;
            font-weight: bold;
            pointer-events: auto;
        }

        button:active { transform: translateY(4px); box-shadow: 0 1px 0 #1a252f; }
        button:disabled { filter: grayscale(1); cursor: not-allowed; opacity: 0.6; }

        button.mode-btn {
            display: block;
            width: 80%;
            margin: 10px auto;
            font-size: 1.1em;
            padding: 12px;
            background: linear-gradient(to right, #e74c3c, #c0392b); /* Red for rescue */
            box-shadow: 0 4px 0 #96281b;
        }
        button.mode-btn:active { box-shadow: 0 1px 0 #96281b; }

        button.secondary {
            background: linear-gradient(to right, #27ae60, #2ecc71); /* Green */
            box-shadow: 0 4px 0 #219150;
        }
        button.secondary:active { box-shadow: 0 1px 0 #219150; }

        /* Input Field */
        input[type="text"] {
            padding: 10px;
            font-size: 1em;
            border: 2px solid #ccc;
            border-radius: 4px;
            width: 60%;
            text-align: center;
            margin-bottom: 10px;
            background: #f9f9f9;
        }

        /* Upgrade Sections */
        .upgrade-section {
            background: #ecf0f1;
            border: 2px solid #bdc3c7;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            text-align: center;
        }
        .upgrade-section h3 { margin: 0 0 10px 0; font-size: 1em; color: #2c3e50; }

        /* Launcher Upgrade Button */
        .launcher-btn {
            background: linear-gradient(to right, #f1c40f, #f39c12);
            box-shadow: 0 4px 0 #d35400;
            font-weight: bold;
            color: #2c3e50;
            width: 100%;
            margin: 0;
        }
        .launcher-btn:active { box-shadow: 0 1px 0 #d35400; }

        /* Leaderboard Table */
        .rank-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 0.9em;
        }
        .rank-table th { background: #34495e; padding: 8px; color: white; }
        .rank-table td { border-bottom: 1px solid #ddd; padding: 8px; color: #333; }
        .rank-table tr:nth-child(even) { background: #f2f2f2; }

        /* Cat Selection Cards */
        .cat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 8px;
            margin: 15px 0;
        }
        .cat-card {
            background: #fff;
            border: 2px solid #bdc3c7;
            border-radius: 8px;
            padding: 5px;
            cursor: pointer;
            position: relative;
            transition: transform 0.1s;
        }
        .cat-card:hover { transform: translateY(-2px); }
        .cat-card.selected { border-color: #3498db; background: #ebf5fb; transform: scale(1.1); z-index: 2; box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
        .cat-card.used { opacity: 0.4; filter: grayscale(1); cursor: default; }

        .hidden { display: none !important; }

        @keyframes popIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div id="hud" class="hidden">
        <div style="display:flex; flex-direction:column;">
            <div class="hud-box">
                <button class="menu-btn" onclick="location.reload()">ğŸ  é¸å–®</button>
                <span>ğŸ’° <span id="moneyDisplay" class="money-text">0</span></span>
            </div>
            <div class="hud-box">ğŸ† æœ€é«˜: <span id="highScoreDisplay">0</span></div>
            <div class="hud-box" id="levelDisplayBox">é—œå¡: <span id="levelDisplay">1</span></div>
            <div class="hud-box hidden" id="distanceBox">ç¸½è·é›¢: <span id="totalDistDisplay">0</span>m</div>
        </div>
        <div style="display:flex; flex-direction:column; align-items:flex-end;">
            <div class="hud-box">è²“å’ª: <span id="catCountDisplay">0</span></div>
            <div class="hud-box" id="targetDisplayBox" style="color:#e74c3c">ç½é ­: <span id="canDisplay">0</span></div>
            <div class="hud-box hidden" id="comboDisplay" style="color:#e67e22">Combo!</div>
        </div>
    </div>

    <!-- Skill Indicator -->
    <div id="skill-indicator">SKILL READY! (SPACE/CLICK)</div>

    <!-- Start Screen -->
    <div id="startScreen" class="ui-layer interactive">
        <div class="panel">
            <h1>ğŸ‘‘ Queen Meow çš„æ•‘æ´ä½œæˆ°</h1>
            <p>ç´¯ç©é‡‘å¹£ï¼Œå‡ç´šé«˜ç§‘æŠ€å½ˆå°„å™¨ï¼<br>æ¯éä¸€é—œï¼Œæœƒç²å¾—ä¸€éš»é¡å¤–çš„è²“å’ªæ”¯æ´ï¼</p>
            
            <div style="margin: 10px 0;">
                <input type="text" id="playerNameInput" placeholder="è¼¸å…¥åå­— (é è¨­: ç„¡åè²“)" maxlength="8">
                <button class="secondary" onclick="game.showLeaderboard()" style="padding: 8px 15px; font-size: 0.9em; min-width: auto;">ğŸ† æ’è¡Œæ¦œ</button>
            </div>

            <div class="upgrade-section">
                <h3>âš¡ é›¢å­å½ˆå°„å™¨å‡ç´š (Lv.<span id="startLauncherLv">1</span>)</h3>
                <button id="startUpgradeBtn" class="launcher-btn" onclick="game.buyLauncherUpgrade()">
                    å¼·åŒ–ç™¼å°„åŠŸç‡ ($500)
                </button>
            </div>

            <div style="font-size:1.1em; color:#d35400; font-weight:bold; margin-top:10px;">æŒæœ‰é‡‘å¹£: ğŸ’°<span id="startMoneyDisplay">0</span></div>

            <button class="mode-btn" onclick="game.initMode('RESCUE')">ğŸš€ é—–é—œæ•‘æ´æ¨¡å¼</button>
            <button class="mode-btn secondary" onclick="game.initMode('DISTANCE')">ğŸŒ¸ èŠ±åœ’é£›é æ¨¡å¼</button>
        </div>
    </div>

    <!-- Leaderboard Screen -->
    <div id="leaderboardScreen" class="ui-layer interactive hidden">
        <div class="panel">
            <h2>ğŸ† è‹±é›„æ’è¡Œæ¦œ</h2>
            <div style="max-height: 300px; overflow-y: auto;">
                <table class="rank-table">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>å§“å</th>
                            <th>åˆ†æ•¸</th>
                            <th>æ—¥æœŸ</th>
                            <th>æ™‚é–“</th>
                        </tr>
                    </thead>
                    <tbody id="leaderboardBody">
                        <!-- JS å¡«å…¥ -->
                    </tbody>
                </table>
            </div>
            <button class="secondary" onclick="document.getElementById('leaderboardScreen').classList.add('hidden'); document.getElementById('startScreen').classList.remove('hidden');">è¿”å›</button>
        </div>
    </div>

    <!-- Level Cleared / Failed -->
    <div id="resultScreen" class="ui-layer interactive hidden">
        <div class="panel">
            <h1 id="resultTitle">MISSION ACCOMPLISHED</h1>
            <p id="resultMsg">å¥³ç‹ç²æ•‘äº†!</p>
            <h2 id="resultScore">0</h2>
            <p id="newRecordMsg" style="color:#e74c3c; font-weight:bold; display:none;">âœ¨ NEW RECORD! âœ¨</p>
            
            <div style="font-size:1em; color:#d35400; font-weight:bold;">æŒæœ‰é‡‘å¹£: ğŸ’°<span id="resultMoneyDisplay">0</span></div>

            <!-- Result Screen Upgrades -->
            <div class="upgrade-section">
                <h3>âš¡ æˆ°åœ°å‡ç´š (Lv.<span id="resultLauncherLv">1</span>)</h3>
                <button id="resultUpgradeBtn" class="launcher-btn" onclick="game.buyLauncherUpgrade()">
                    å¼·åŒ–ç™¼å°„åŠŸç‡ ($500)
                </button>
            </div>

            <div id="nextLevelControls" style="display: flex; justify-content: center; gap: 10px; margin-top: 15px;">
                <button id="nextLevelBtn" class="hidden" onclick="game.nextLevel()">ä¸‹ä¸€é—œ â¡</button>
                <button id="retryLevelBtn" class="hidden" onclick="game.retryLevel()">é‡è©¦æœ¬é—œ â†º</button>
            </div>
            <button class="secondary" onclick="location.reload()">æ”¾æ£„ä¸¦å›ä¸»é¸å–®</button>
        </div>
    </div>

    <!-- Cat Selector (Between Shots) -->
    <div id="selectScreen" class="ui-layer interactive hidden">
        <div class="panel" style="padding: 15px; width: 350px;">
            <h3 style="margin:5px 0;">é¸æ“‡ä¸‹ä¸€ä½å‹‡è€…</h3>
            <div class="cat-grid" id="catGrid"></div>
            <div id="catDesc" style="font-size:0.85em; color:#666; height:40px;">...</div>
            <button id="launchBtn" disabled>æº–å‚™ç™¼å°„</button>
        </div>
    </div>

<script>
/**
 * Cat Can Rescue: Queen Meow's Rescue Operation
 * Features: Infinite Levels, Cat Growth, Leaderboard, Tech Launcher, Extra Cats per Level
 */

// --- 1. CONFIG & DATA ---
const CONFIG = {
    gravity: 0.25,
    groundFriction: 0.95,
    airDrag: 0.998,
    stopVelocity: 0.15,
    meterScale: 0.1,
    debug: false,
    basePower: 0.22, 
    width: 0, 
    height: 0
};

// è²“å’ªè³‡æ–™ (åŠå¾‘å·²åŠ å€ï¼Œç§»é™¤æŠ€èƒ½å‡ç´šç›¸é—œæ¬„ä½)
const CAT_TYPES = [
    { id: 'orange', name: 'å°æ©˜', color: '#FFB347', mass: 1.0, radius: 30, skill: 'DASH', desc: 'æŠ€èƒ½: äºŒæ®µåŠ é€Ÿè¡åˆº' }, 
    { id: 'black', name: 'é»‘è²“', color: '#333333', mass: 1.0, radius: 28, skill: 'CLONE', desc: 'æŠ€èƒ½: å½±åˆ†èº«æ”»æ“Š' }, 
    { id: 'cow', name: 'ä¹³ç‰›', color: '#EEEEEE', pattern: 'cow', mass: 1.3, radius: 32, skill: 'QUAKE', desc: 'æŠ€èƒ½: è½åœ°å¤§åœ°éœ‡' }, 
    { id: 'calico', name: 'ä¸‰èŠ±', color: '#FFFFFF', pattern: 'calico', mass: 1.0, radius: 30, skill: 'FLOWER_BOMB', desc: 'æŠ€èƒ½: ç©ºä¸­èŠ±ç“£ç‚¸è£‚' }, 
    { id: 'tabby', name: 'è™æ–‘', color: '#A0A0A0', pattern: 'stripe', mass: 1.4, radius: 32, skill: 'DRILL', desc: 'æŠ€èƒ½: é‘½é ­æ»¾å‹• (ä½æ‘©æ“¦)' }, 
    { id: 'white', name: 'ç™½è²“', color: '#F0F8FF', mass: 0.8, radius: 26, skill: 'STEER', desc: 'æŠ€èƒ½: æŸ”é¢¨è½‰å‘ (å¯æ§)' }, 
    { id: 'chubby', name: 'èƒ–èƒ–', color: '#FFD1DC', mass: 2.0, radius: 44, skill: 'GIANT', desc: 'æŠ€èƒ½: å·¨å¤§åŒ–æ’æ“Š' } 
];

const CAN_W = 70; 
const CAN_H = 70; 
const BASE_H = 40; 

// --- Dynamic Level Generator ---
function generateLevelData(levelIndex) {
    const levelNum = levelIndex + 1;
    const startX = 1000 + (levelIndex * 150); 
    
    const numStacks = 3 + Math.floor(levelIndex / 3); 
    const stackHeight = 3 + Math.floor(levelIndex / 4); 
    
    let entities = [];

    for (let i = 0; i < numStacks; i++) {
        const stackX = startX + (i * 160); 
        entities.push({t: (i%3)+1, x: stackX, y: 0, w: 80, h: 40});
        
        for(let h = 0; h < stackHeight; h++) {
            const yPos = 40 + h * (CAN_H) + (h * 4) + 2; 
            if (h % 2 === 0) {
                entities.push({t: 9, x: stackX + 5, y: yPos});
            } else {
                entities.push({t: 9, x: stackX - 20, y: yPos});
                entities.push({t: 9, x: stackX + 30, y: yPos});
            }
        }
    }

    if (levelNum % 5 === 0) {
        entities.push({t: 10, x: startX + (numStacks * 160) / 2, y: stackHeight * 80}); 
    }

    entities.push({t: 99, x: startX + numStacks * 160 + 200, y: 0});

    return {
        name: `Lv.${levelNum} é å¾æ•‘æ´`,
        entities: entities
    };
}

// --- 2. AUDIO SYSTEM ---
class AudioController {
    constructor() {
        this.ctx = null;
        this.enabled = false;
    }
    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.enabled = true;
        }
        if(this.ctx.state === 'suspended') this.ctx.resume();
    }
    playTone(freq, type, dur, vol=0.1, slide=0) {
        if (!this.enabled) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        if(slide !== 0) osc.frequency.linearRampToValueAtTime(freq + slide, this.ctx.currentTime + dur);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + dur);
    }
    playShoot() { this.playTone(200, 'sawtooth', 0.3, 0.1, 400); }
    playHit() { this.playTone(100, 'square', 0.1, 0.2, -50); }
    playBreak() { 
        this.playTone(50, 'sawtooth', 0.1, 0.2); 
        setTimeout(()=>this.playTone(80, 'square', 0.1, 0.1), 50);
    }
    playCanHit() { this.playTone(600, 'sine', 0.1, 0.1, 200); } 
    playWin() { 
        [0, 200, 400, 600].forEach((d, i) => setTimeout(() => this.playTone(400 + i*100, 'triangle', 0.3, 0.2), d));
    }
    playSkill() { this.playTone(800, 'sine', 0.4, 0.2, -400); }
    playCoin() { this.playTone(1200, 'sine', 0.1, 0.1); setTimeout(()=>this.playTone(1600, 'sine', 0.1, 0.1), 50); } 
    playBuy() { this.playTone(400, 'square', 0.2, 0.2, 200); }
    playExplosion() { 
        this.playTone(100, 'sawtooth', 0.5, 0.3, -80); 
        this.playTone(50, 'square', 0.5, 0.3, -20);
    }
}

// --- 3. PHYSICS & ENTITIES ---

class Entity {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.delete = false;
    }
}

class Obstacle extends Entity {
    constructor(def, groundY) {
        let w = def.w || 40;
        let h = def.h || 40;
        if (def.t === 9) { w = CAN_W; h = CAN_H; }
        if (def.t === 10) { w = 120; h = 120; }
        super(def.x, groundY - def.y - h); 
        
        this.w = w;
        this.h = h;
        this.type = def.t; 
        this.vx = 0;
        this.vy = 0;
        this.hp = this.getMaxHP();
        this.maxHp = this.hp;
        this.rotation = def.rot || 0;
        this.isStatic = false; 
        this.friction = this.type === 2 ? 0.99 : 0.8;
    }

    getMaxHP() {
        switch(this.type) {
            case 1: return 60; 
            case 2: return 40; 
            case 3: return 200; 
            case 9: return 10; 
            case 10: return 500; 
            default: return 9999;
        }
    }

    getBounty() {
        switch(this.type) {
            case 1: return 10;
            case 2: return 20;
            case 3: return 30;
            case 9: return 100;
            case 10: return 500;
            default: return 0;
        }
    }

    update(gravity, groundY) {
        if (this.type === 99) return; 

        if (this.y + this.h < groundY) {
            this.vy += gravity;
        } else if (this.y + this.h >= groundY) {
            this.y = groundY - this.h;
            this.vy = -this.vy * 0.3; 
            this.vx *= this.friction;
            if (Math.abs(this.vy) < 0.5) this.vy = 0;
        }

        this.x += this.vx;
        this.y += this.vy;

        if (this.hp <= 0 || this.x > 3000 || this.x < -500) {
            this.delete = true;
            return true; 
        }
        return false;
    }

    takeDamage(amount) {
        this.hp -= amount;
        game.particles.push(new Particle(this.x + this.w/2, this.y + this.h/2, this.getColor(), 3));
    }

    getColor() {
        switch(this.type) {
            case 1: return '#8D6E63';
            case 2: return '#B3E5FC';
            case 3: return '#757575';
            case 9: return '#FFF9C4';
            case 10: return '#FFD700';
            default: return '#FFF';
        }
    }
}

class Particle extends Entity {
    constructor(x, y, color, speed=5) {
        super(x, y);
        this.vx = (Math.random() - 0.5) * speed;
        this.vy = (Math.random() - 0.5) * speed;
        this.life = 40 + Math.random() * 20;
        this.color = color;
        this.size = Math.random() * 4 + 2;
        this.isText = false;
        this.text = "";
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        if (!this.isText) this.vy += 0.1; 
        else this.vy -= 0.5; // Float up text
        if (this.life <= 0) this.delete = true;
    }
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life / 60);
        if (this.isText) {
            ctx.fillStyle = '#FFFF00';
            ctx.font = 'bold 20px Arial';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 3;
            ctx.strokeText(this.text, this.x, this.y);
            ctx.fillText(this.text, this.x, this.y);
        } else {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }
}

// --- 4. GAME ENGINE ---

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.audio = new AudioController();
        
        this.mode = 'RESCUE'; 
        this.levelIdx = 0;
        this.state = 'MENU'; 
        
        this.cat = null;
        this.obstacles = [];
        this.particles = [];
        this.flowers = [];
        this.cameraX = 0;
        this.gameFrame = 0;
        this.cansLeft = 0; 
        
        this.slingX = 150;
        this.slingY = 0; 
        this.dragStart = null;
        this.dragCurrent = null;
        this.flyTimer = 0;
        
        this.score = 0;
        this.catsUsed = 0;
        this.catsPool = [];
        this.totalDistance = 0; 
        
        this.money = 0;
        this.launcherLevel = 1;

        this.playerName = "ç„¡åè²“";
        this.leaderboard = []; 
        this.loadSave();
        
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.bindInput();
        
        this.updateUI();
        this.lastTime = 0;
        requestAnimationFrame(t => this.loop(t));
    }

    loadSave() {
        try {
            const saved = localStorage.getItem('catRescueData_v4'); // New version
            if (saved) {
                const data = JSON.parse(saved);
                this.money = data.money || 0;
                this.launcherLevel = data.launcherLevel || 1;
                this.leaderboard = data.leaderboard || [];
                if(data.lastPlayerName) document.getElementById('playerNameInput').value = data.lastPlayerName;
            }
        } catch(e) {
            console.error("Save load error", e);
        }
    }

    saveData() {
        const nameInput = document.getElementById('playerNameInput');
        if (nameInput && nameInput.value) {
            this.playerName = nameInput.value;
        }

        const data = {
            money: this.money,
            launcherLevel: this.launcherLevel,
            leaderboard: this.leaderboard,
            lastPlayerName: this.playerName
        };
        localStorage.setItem('catRescueData_v4', JSON.stringify(data));
        this.updateUI();
    }

    saveRecord() {
        if (this.score <= 0) return;

        const nameInput = document.getElementById('playerNameInput');
        const name = (nameInput && nameInput.value) ? nameInput.value : "ç„¡åè²“";
        const now = new Date();
        const dateStr = now.toLocaleDateString();
        const timeStr = now.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});

        const record = {
            name: name,
            score: this.score,
            date: dateStr,
            time: timeStr
        };

        this.leaderboard.push(record);
        this.leaderboard.sort((a, b) => b.score - a.score);
        if (this.leaderboard.length > 20) this.leaderboard.pop();
        
        this.saveData();
    }

    showLeaderboard() {
        document.getElementById('startScreen').classList.add('hidden');
        document.getElementById('leaderboardScreen').classList.remove('hidden');
        
        const tbody = document.getElementById('leaderboardBody');
        tbody.innerHTML = '';
        
        this.leaderboard.forEach((rec, index) => {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td>${index + 1}</td>
                <td>${rec.name}</td>
                <td style="color: #d84315; font-weight: bold;">${rec.score}</td>
                <td>${rec.date}</td>
                <td>${rec.time}</td>
            `;
            tbody.appendChild(tr);
        });

        if (this.leaderboard.length === 0) {
            tbody.innerHTML = '<tr><td colspan="5">å°šç„¡ç´€éŒ„ï¼Œå¿«å»æŒ‘æˆ°å§ï¼</td></tr>';
        }
    }

    addMoney(amount, x, y) {
        this.money += amount;
        if (this.mode === 'RESCUE') {
            this.score += amount; 
        }
        this.saveData();
        
        if (x !== undefined && y !== undefined) {
            const p = new Particle(x, y, '', 0);
            p.isText = true;
            p.text = `+$${amount}`;
            p.life = 60;
            this.particles.push(p);
        }
    }

    getLauncherCost() {
        return this.launcherLevel * 500;
    }

    buyLauncherUpgrade() {
        const cost = this.getLauncherCost();
        if (this.money >= cost) {
            this.money -= cost;
            this.launcherLevel++;
            this.audio.playBuy();
            this.saveData();
        } else {
            alert(`é‡‘å¹£ä¸è¶³ï¼`);
        }
        this.updateUI(); 
    }

    getLaunchPower() {
        return CONFIG.basePower * (1 + (this.launcherLevel - 1) * 0.1);
    }

    getCatScale() {
        // Cat grows 10% per level passed
        return 1.0 + (this.levelIdx * 0.1);
    }

    resize() {
        CONFIG.width = window.innerWidth;
        CONFIG.height = window.innerHeight;
        this.canvas.width = CONFIG.width;
        this.canvas.height = CONFIG.height;
        this.slingY = CONFIG.height - 150;
    }

    initMode(modeName) {
        this.audio.init();
        
        const nameInput = document.getElementById('playerNameInput');
        if(nameInput && nameInput.value.trim() !== "") {
            this.playerName = nameInput.value.trim();
        } else {
            this.playerName = "ç„¡åè²“";
        }

        this.mode = modeName;
        this.levelIdx = 0;
        this.score = 0;
        this.totalDistance = 0;
        
        document.getElementById('startScreen').classList.add('hidden');
        document.getElementById('leaderboardScreen').classList.add('hidden');
        document.getElementById('resultScreen').classList.add('hidden');
        document.getElementById('hud').classList.remove('hidden');
        
        if (modeName === 'RESCUE') {
            document.getElementById('targetDisplayBox').classList.remove('hidden');
            document.getElementById('levelDisplayBox').classList.remove('hidden');
            document.getElementById('distanceBox').classList.add('hidden');
            this.startLevel(0);
        } else {
            document.getElementById('targetDisplayBox').classList.add('hidden');
            document.getElementById('levelDisplayBox').classList.add('hidden');
            document.getElementById('distanceBox').classList.remove('hidden');
            this.catsPool = [...CAT_TYPES]; 
            this.obstacles = [];
            this.startTurn();
        }
        this.updateUI();
    }

    startLevel(idx) {
        this.levelIdx = idx;
        const levelData = generateLevelData(idx); 
        this.obstacles = [];
        this.flowers = [];
        this.particles = [];
        
        // Generate Cat Pool: Base 7 + Extras
        this.catsPool = [...CAT_TYPES]; 
        // Add random extra cats based on level index
        for(let i = 0; i < idx; i++) {
            const randomCat = CAT_TYPES[Math.floor(Math.random() * CAT_TYPES.length)];
            this.catsPool.push(randomCat);
        }
        // Shuffle pool
        this.catsPool.sort(() => Math.random() - 0.5);

        this.catsUsed = 0;
        this.cameraX = 0;
        this.cansLeft = 0; 
        
        const groundY = CONFIG.height - 100;
        levelData.entities.forEach(e => {
            this.obstacles.push(new Obstacle(e, groundY));
            if(e.t === 9 || e.t === 10) this.cansLeft++;
        });

        document.getElementById('levelDisplay').innerText = idx + 1;
        this.updateHUD();
        this.startTurn();
    }

    startTurn() {
        if (this.catsPool.length === 0) {
            if (this.mode === 'RESCUE') {
                if (this.checkWinCondition()) {
                    this.winLevel();
                } else {
                    this.failLevel();
                }
            } else {
                this.endGameDistance();
            }
            return;
        }

        this.state = 'SELECT';
        this.cameraX = 0; 
        try {
            this.renderCatSelector();
            document.getElementById('selectScreen').classList.remove('hidden');
            document.getElementById('skill-indicator').style.display = 'none';
        } catch(e) {
            console.error("UI Error in startTurn", e);
        }
    }

    renderCatSelector() {
        const grid = document.getElementById('catGrid');
        if(!grid) return;
        grid.innerHTML = '';
        const desc = document.getElementById('catDesc');
        const btn = document.getElementById('launchBtn');
        if(btn) btn.disabled = true;
        this.selectedCatType = null;

        this.catsPool.forEach((cat, i) => {
            const el = document.createElement('div');
            el.className = 'cat-card';
            el.style.borderColor = cat.color;
            el.innerHTML = `
                <div style="font-size:24px;">ğŸ±</div>
                <div style="font-size:10px;">${cat.name}</div>
            `;
            el.onclick = () => {
                document.querySelectorAll('.cat-card').forEach(c => c.classList.remove('selected'));
                el.classList.add('selected');
                this.selectedCatType = cat;
                this.selectedCatIdx = i; 
                if(desc) desc.innerText = `${cat.desc}`;
                if(btn) btn.disabled = false;
            };
            grid.appendChild(el);
        });

        if(btn) btn.onclick = () => {
            if (this.selectedCatType) {
                this.catsPool.splice(this.selectedCatIdx, 1);
                
                const scale = this.getCatScale();
                
                this.cat = {
                    ...this.selectedCatType,
                    radius: this.selectedCatType.radius * scale, 
                    mass: this.selectedCatType.mass * scale, 
                    x: this.slingX,
                    y: this.slingY,
                    vx: 0, vy: 0,
                    rotation: 0,
                    skillUsed: false,
                    onGround: false,
                    stopped: false,
                    stopTimer: 0
                };
                
                document.getElementById('selectScreen').classList.add('hidden');
                this.state = 'AIM';
                this.updateHUD();
            }
        };
    }

    bindInput() {
        const start = (pos) => {
            if (this.state === 'AIM') {
                const dx = pos.x - (this.slingX - this.cameraX);
                const dy = pos.y - this.slingY;
                if (Math.hypot(dx, dy) < 100) {
                    this.dragStart = {x: this.slingX, y: this.slingY};
                    this.dragCurrent = pos;
                }
            } else if (this.state === 'FLY' && this.cat && !this.cat.skillUsed) {
                this.activateSkill();
            }
        };
        const move = (pos) => {
            if (this.state === 'AIM' && this.dragStart) {
                let dx = pos.x - this.slingX;
                let dy = pos.y - this.slingY;
                const len = Math.hypot(dx, dy);
                if (len > 150) {
                    const r = 150/len;
                    dx *= r; dy *= r;
                }
                this.dragCurrent = {x: this.slingX + dx, y: this.slingY + dy};
            }
        };
        const end = () => {
            if (this.state === 'AIM' && this.dragStart) {
                this.launch();
            }
            this.dragStart = null;
        };
        
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                 if (this.state === 'FLY' && !this.cat.skillUsed) this.activateSkill();
            }
            if (e.code === 'ArrowRight' && this.cat && this.cat.skill === 'STEER' && this.cat.skillUsed) {
                this.cat.vx += 0.5;
            }
            if (e.code === 'ArrowLeft' && this.cat && this.cat.skill === 'STEER' && this.cat.skillUsed) {
                this.cat.vx -= 0.5;
            }
        });

        const getPos = (e) => {
            const r = this.canvas.getBoundingClientRect();
            return {x: e.clientX - r.left, y: e.clientY - r.top};
        };
        
        this.canvas.addEventListener('mousedown', e => start(getPos(e)));
        window.addEventListener('mousemove', e => move(getPos(e)));
        window.addEventListener('mouseup', end);
        
        this.canvas.addEventListener('touchstart', e => start(getPos(e.changedTouches[0])), {passive:false});
        window.addEventListener('touchmove', e => { e.preventDefault(); move(getPos(e.changedTouches[0])); }, {passive:false});
        window.addEventListener('touchend', end);
    }

    launch() {
        if (!this.dragCurrent) return;
        const dx = this.slingX - this.dragCurrent.x;
        const dy = this.slingY - this.dragCurrent.y;
        
        const power = this.getLaunchPower(); 
        this.cat.vx = dx * power;
        this.cat.vy = dy * power;
        
        this.state = 'FLY';
        this.flyTimer = 0; 
        this.audio.playShoot();
        
        document.getElementById('skill-indicator').style.display = 'block';
    }

    activateSkill() {
        if (!this.cat || this.cat.skillUsed) return;
        this.cat.skillUsed = true;
        this.audio.playSkill();
        document.getElementById('skill-indicator').style.display = 'none';
        
        const s = this.cat.skill;
        const lv = 1; // Default skill level (removed paid upgrade)

        if (s === 'DASH') {
            this.cat.vx *= (1.8 + lv * 0.2); 
            this.addEffect(this.cat.x, this.cat.y, 'burst');
        } 
        else if (s === 'CLONE') {
            const count = 2 + Math.floor(lv / 2);
            for(let i=0; i<count; i++) {
                const p1 = new Particle(this.cat.x, this.cat.y + (i*10-10), '#333', 0);
                p1.vx = this.cat.vx; p1.vy = this.cat.vy; p1.life = 100; p1.size = 14; p1.isClone = true;
                this.particles.push(p1);
            }
        } 
        else if (s === 'FLOWER_BOMB') {
            this.audio.playExplosion();
            const count = 8 + lv * 2;
            for(let i=0; i<count; i++) {
                const f = {x: this.cat.x + (Math.random()-0.5)*150, y: this.cat.y + (Math.random()-0.5)*150, scale:0, targetScale:1, color:'red', type: 'bomb'};
                this.flowers.push(f);
                const p = new Particle(this.cat.x, this.cat.y, 'orange', 10);
                p.life = 20;
                this.particles.push(p);
            }
        } 
        else if (s === 'DRILL') {
            this.cat.mass *= (2 + lv * 0.5); 
        } 
        else if (s === 'GIANT') {
            this.cat.radius *= (1 + lv * 0.3); 
            this.cat.mass *= (1 + lv * 0.5); 
            this.audio.playExplosion(); 
        } 
        else if (s === 'QUAKE') {
            this.cat.quakeReady = true; 
            this.cat.quakeLevel = lv; 
        }
    }

    update(dt) {
        this.gameFrame++;
        if (!this.cat && this.state === 'FLY') {
             this.state = 'END_SHOT';
        }

        const groundY = CONFIG.height - 100;

        // --- 1. Cat Physics ---
        if (this.state === 'FLY' && this.cat) {
            this.flyTimer++;
            if (this.flyTimer > 600) { 
                this.state = 'END_SHOT';
                document.getElementById('skill-indicator').style.display = 'none';
                this.resolveTurn();
                return;
            }

            if (this.gameFrame % 4 === 0 && Math.abs(this.cat.vx) > 3) {
                const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];
                const p = new Particle(this.cat.x, this.cat.y, colors[Math.floor(Math.random()*colors.length)], 2);
                this.particles.push(p);
            }

            let drag = CONFIG.airDrag;
            if (this.cat.skill === 'DRILL' && this.cat.skillUsed) drag = 1.0; 
            
            this.cat.vx *= drag;
            this.cat.vy *= drag;
            this.cat.vy += CONFIG.gravity * this.cat.mass;

            this.cat.x += this.cat.vx;
            this.cat.y += this.cat.vy;
            this.cat.rotation += this.cat.vx * 0.05;

            if (this.cat.y + this.cat.radius > groundY) {
                this.cat.y = groundY - this.cat.radius;
                this.cat.vy *= -0.6; 
                this.cat.vx *= CONFIG.groundFriction;
                this.cat.onGround = true;
                
                if (this.cat.skill === 'QUAKE' && this.cat.skillUsed && this.cat.quakeReady) {
                    this.cat.quakeReady = false;
                    this.shakeObstacles();
                    this.audio.playBreak();
                }

                if (Math.abs(this.cat.vx) > 1) {
                    this.addFlower(this.cat.x, groundY);
                }
            } else {
                this.cat.onGround = false;
                if (Math.random() < 0.1) this.particles.push(new Particle(this.cat.x, this.cat.y, '#FFC0CB'));
            }

            if (Math.abs(this.cat.vx) < CONFIG.stopVelocity && Math.abs(this.cat.vy) < CONFIG.stopVelocity && this.cat.onGround) {
                this.cat.stopTimer++;
                if (this.cat.stopTimer > 60) {
                    this.state = 'END_SHOT';
                    document.getElementById('skill-indicator').style.display = 'none';
                    setTimeout(() => this.resolveTurn(), 1000);
                }
            } else {
                this.cat.stopTimer = 0;
            }

            if (this.cat.x > 3000 || this.cat.x < -200) {
                this.state = 'END_SHOT';
                setTimeout(() => this.resolveTurn(), 500);
            }
        }

        // --- 2. Obstacle Physics & Collision ---
        let cansAlive = 0;

        for (let i = this.obstacles.length - 1; i >= 0; i--) {
            const ob = this.obstacles[i];
            
            let supported = false;
            if (ob.y + ob.h >= groundY - 1) {
                supported = true;
            } else {
                for (let j = 0; j < this.obstacles.length; j++) {
                    if (i === j) continue;
                    const other = this.obstacles[j];
                    if (Math.abs((ob.x + ob.w/2) - (other.x + other.w/2)) < (ob.w/2 + other.w/2) * 0.7) {
                         if (ob.y + ob.h >= other.y && ob.y + ob.h <= other.y + 20) {
                             supported = true;
                             ob.y = other.y - ob.h; 
                             ob.vy = 0;
                             break;
                         }
                    }
                }
            }
            
            if (!supported && ob.type !== 99) {
                ob.vy += CONFIG.gravity;
            } else if (supported && ob.vy > 0) {
                ob.vy = 0;
                ob.vx *= 0.8; 
            }
            
            if(ob.update(CONFIG.gravity, groundY)) {
                this.addMoney(ob.getBounty(), ob.x + ob.w/2, ob.y);
                
                if (ob.type === 9 || ob.type === 10) {
                     this.audio.playCanHit();
                     this.addEffect(ob.x, ob.y, 'stars');
                } else {
                    this.audio.playBreak();
                    this.audio.playCoin(); 
                }
                this.obstacles.splice(i, 1);
                continue;
            }

            if (ob.type === 9 || ob.type === 10) cansAlive++;

            if (this.state === 'FLY' && this.cat) {
                this.checkCollision(this.cat, ob);
            }
            
            this.particles.forEach(p => {
                if(p.isClone) this.checkCollision({x:p.x, y:p.y, vx:p.vx, vy:p.vy, radius:p.size, mass:0.5}, ob, true);
            });
        }

        this.cansLeft = cansAlive;
        this.updateHUD();

        // --- 3. Particles ---
        this.particles.forEach(p => p.update());
        this.particles = this.particles.filter(p => !p.delete);
        
        this.flowers.forEach(f => {
            if(f.scale < f.targetScale) f.scale += 0.05;
        });

        // --- 4. Camera ---
        let targetCamX = 0;
        if (this.state === 'FLY' && this.cat) {
            targetCamX = this.cat.x - CONFIG.width * 0.3;
        } else if (this.state === 'AIM') {
            targetCamX = 0;
        } else if (this.state === 'END_SHOT' && this.obstacles.length > 0) {
            if(this.cat) targetCamX = this.cat.x - CONFIG.width * 0.3;
        }
        
        targetCamX = Math.max(0, targetCamX);
        this.cameraX += (targetCamX - this.cameraX) * 0.1;
    }

    checkCollision(circle, rect, isClone=false) {
        const clamp = (val, min, max) => Math.max(min, Math.min(val, max));
        const closestX = clamp(circle.x, rect.x, rect.x + rect.w);
        const closestY = clamp(circle.y, rect.y, rect.y + rect.h);

        const dx = circle.x - closestX;
        const dy = circle.y - closestY;
        const distSq = dx*dx + dy*dy;

        if (distSq < (circle.radius * circle.radius)) {
            const dist = Math.sqrt(distSq);
            const overlap = circle.radius - dist;
            
            let nx = dx / (dist || 1);
            let ny = dy / (dist || 1);
            if (dist === 0) { nx = 0; ny = -1; }

            if(!isClone) {
                circle.x += nx * overlap;
                circle.y += ny * overlap;
            }

            const relativeV = Math.hypot(circle.vx, circle.vy);
            
            if (relativeV > 1.5) {
                const damage = relativeV * circle.mass * (isClone?5:10); 
                rect.takeDamage(damage);
                if (!isClone) this.audio.playHit();
            }

            if(!isClone) {
                const dot = circle.vx * nx + circle.vy * ny;
                circle.vx = (circle.vx - 2 * dot * nx) * 0.7; 
                circle.vy = (circle.vy - 2 * dot * ny) * 0.7;
            } else {
                rect.vx += circle.vx * 0.2;
            }
            
            rect.vx += nx * -1 * relativeV * 0.2;
            rect.vy += ny * -1 * relativeV * 0.1;
        }
    }

    shakeObstacles() {
        this.obstacles.forEach(ob => {
            if(ob.y > CONFIG.height - 200) {
                ob.hp -= 20; 
                ob.vy -= 3; 
                ob.vx += (Math.random()-0.5)*5;
            }
        });
    }

    resolveTurn() {
        // Distance Calculation
        if (this.mode === 'DISTANCE' && this.cat) {
            const dist = Math.floor((this.cat.x - this.slingX) * CONFIG.meterScale);
            if (dist > 0) {
                this.score += dist; // Add to score
                this.totalDistance += dist; // Track for HUD
                this.addMoney(Math.floor(dist/10), this.cat.x, this.cat.y - 50);
                
                // Landing Mark
                const p = new Particle(this.cat.x, CONFIG.height-100, '#000', 0);
                p.isText = true;
                p.text = `${dist}m`;
                p.life = 200; // Stay longer
                p.vy = -0.5; // Float up slowly
                this.particles.push(p);
            }
        }

        this.cat = null; 
        
        if (this.mode === 'RESCUE') {
            if (this.checkWinCondition()) {
                this.winLevel();
            } else {
                this.startTurn();
            }
        } else {
            this.startTurn();
        }
    }

    checkWinCondition() {
        return this.obstacles.filter(o => o.type === 9 || o.type === 10).length === 0;
    }

    winLevel() {
        this.state = 'LEVEL_END';
        this.audio.playWin();
        
        // Bonus Money for level clear
        this.addMoney(1000); 
        this.saveRecord(); // Save to leaderboard

        setTimeout(() => {
            document.getElementById('resultScreen').classList.remove('hidden');
            document.getElementById('hud').classList.add('hidden');
            document.getElementById('resultTitle').innerText = "å¥³ç‹ç²æ•‘äº†!";
            document.getElementById('resultMsg').innerText = `éé—œçå‹µ +$1000 (è²“å’ªè®Šå¤§äº†!)`;
            document.getElementById('resultScore').innerText = `ç¸½åˆ†: ${this.score}`;
            
            document.getElementById('nextLevelBtn').classList.remove('hidden');
            document.getElementById('retryLevelBtn').classList.add('hidden');
            
            this.updateUI(); 
        }, 1500);
    }

    failLevel() {
        this.saveRecord(); 
        document.getElementById('resultScreen').classList.remove('hidden');
        document.getElementById('hud').classList.add('hidden');
        document.getElementById('resultTitle').innerText = "æ•‘æ´å¤±æ•—...";
        document.getElementById('resultMsg').innerText = `é‚„æœ‰ ${this.cansLeft} å€‹ç½é ­æ²’æ‰“å€’`;
        document.getElementById('resultScore').innerText = `å¾—åˆ†: ${this.score}`;
        
        document.getElementById('nextLevelBtn').classList.add('hidden');
        document.getElementById('retryLevelBtn').classList.remove('hidden');
        
        this.updateUI();
    }
    
    nextLevel() {
        document.getElementById('resultScreen').classList.add('hidden');
        document.getElementById('hud').classList.remove('hidden');
        this.startLevel(this.levelIdx + 1);
    }
    
    retryLevel() {
        document.getElementById('resultScreen').classList.add('hidden');
        document.getElementById('hud').classList.remove('hidden');
        this.startLevel(this.levelIdx);
    }

    endGameDistance() {
        this.saveRecord(); 
        document.getElementById('resultScreen').classList.remove('hidden');
        document.getElementById('hud').classList.add('hidden');
        document.getElementById('resultTitle').innerText = "èŠ±åœ’ä¹‹æ—…çµæŸ";
        document.getElementById('resultMsg').innerText = `ç¸½é£›è¡Œè·é›¢: ${this.totalDistance}m`;
        document.getElementById('resultScore').innerText = `å¾—åˆ†: ${this.score}`;
        
        document.getElementById('nextLevelBtn').classList.add('hidden');
        document.getElementById('retryLevelBtn').classList.remove('hidden');
        document.getElementById('retryLevelBtn').innerText = "å†ç©ä¸€æ¬¡"; 
        document.getElementById('retryLevelBtn').onclick = () => {
             document.getElementById('resultScreen').classList.add('hidden');
             this.initMode('DISTANCE');
        };
        
        this.updateUI();
    }

    addFlower(x, y) {
        if (this.flowers.some(f => Math.abs(f.x - x) < 15)) return;
        const colors = ['#FF69B4', '#FFB6C1', '#FFC0CB', '#FFA07A'];
        this.flowers.push({
            x: x, y: y,
            scale: 0, targetScale: 0.5 + Math.random()*0.5,
            color: colors[Math.floor(Math.random()*colors.length)],
            rotation: Math.random()*Math.PI
        });
        if(this.mode === 'RESCUE') this.score += 10;
        else this.score += 100;
    }

    addEffect(x, y, type) {
        for(let i=0; i<10; i++) {
            this.particles.push(new Particle(x, y, '#FFD700', 8));
        }
    }

    updateUI() {
        // Update Money Displays
        const moneyEl = document.getElementById('moneyDisplay');
        if (moneyEl) moneyEl.innerText = this.money;
        
        const startMoneyEl = document.getElementById('startMoneyDisplay');
        if (startMoneyEl) startMoneyEl.innerText = this.money;
        
        const resultMoneyEl = document.getElementById('resultMoneyDisplay');
        if (resultMoneyEl) resultMoneyEl.innerText = this.money;
        
        // Update Launcher Info
        const launcherLvEl = document.getElementById('startLauncherLv');
        if (launcherLvEl) launcherLvEl.innerText = this.launcherLevel;
        const resultLauncherLvEl = document.getElementById('resultLauncherLv');
        if (resultLauncherLvEl) resultLauncherLvEl.innerText = this.launcherLevel;
        
        const highScoreEl = document.getElementById('highScoreDisplay');
        let topScore = 0;
        if(this.leaderboard.length > 0) topScore = this.leaderboard[0].score;
        if (highScoreEl) highScoreEl.innerText = topScore;
        
        const totalDistDisplay = document.getElementById('totalDistDisplay');
        if(totalDistDisplay) totalDistDisplay.innerText = this.totalDistance;

        const cost = this.getLauncherCost();
        const text = `å¼·åŒ–å½ˆåŠ› ($${cost})`;
        
        const startUpgradeBtn = document.getElementById('startUpgradeBtn');
        if (startUpgradeBtn) {
            startUpgradeBtn.innerText = text;
            startUpgradeBtn.disabled = this.money < cost;
        }
        
        const resultUpgradeBtn = document.getElementById('resultUpgradeBtn');
        if (resultUpgradeBtn) {
            resultUpgradeBtn.innerText = text;
            resultUpgradeBtn.disabled = this.money < cost;
        }

        // HUD Info
        const scoreEl = document.getElementById('scoreDisplay');
        if (scoreEl) scoreEl.innerText = this.score;
        
        const catCountEl = document.getElementById('catCountDisplay');
        if (catCountEl) catCountEl.innerText = this.catsPool.length;
        
        const canDisplayEl = document.getElementById('canDisplay');
        if (this.mode === 'RESCUE' && canDisplayEl) {
            canDisplayEl.innerText = this.cansLeft;
        }
    }

    updateHUD() {
        this.updateUI(); // Keep synced
    }

    // --- 5. RENDER ---
    draw() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, CONFIG.width, CONFIG.height);
        
        ctx.save();
        
        // Background
        ctx.fillStyle = '#87CEEB';
        ctx.fillRect(0, 0, CONFIG.width, CONFIG.height);
        
        this.drawClouds(ctx);
        
        ctx.translate(-this.cameraX, 0);
        
        const groundY = CONFIG.height - 100;
        ctx.fillStyle = '#8BC34A';
        ctx.fillRect(this.cameraX, groundY, CONFIG.width, 100);
        ctx.fillStyle = '#689F38';
        ctx.fillRect(this.cameraX, groundY, CONFIG.width, 10);
        
        this.drawFlowers(ctx);
        this.drawSlingshot(ctx, false);
        
        this.obstacles.forEach(ob => this.drawObstacle(ctx, ob));
        
        if (this.cat) this.drawCat(ctx, this.cat);
        else if (this.state === 'AIM') {
             // Preview Cat
             let x = this.dragCurrent ? this.dragCurrent.x : this.slingX;
             let y = this.dragCurrent ? this.dragCurrent.y : this.slingY;
             const scale = this.getCatScale();
             const previewCat = {
                 ...this.selectedCatType, 
                 x:x, y:y, rotation:0,
                 radius: this.selectedCatType.radius * scale 
             };
             this.drawCat(ctx, previewCat);
             
             // Aim Line (Tech style)
             if(this.dragCurrent) {
                ctx.beginPath();
                ctx.strokeStyle = "rgba(0, 255, 255, 0.5)"; // Cyan laser
                ctx.lineWidth = 2;
                ctx.setLineDash([5,5]);
                ctx.moveTo(x, y);
                ctx.lineTo(this.slingX, this.slingY);
                ctx.stroke();
                ctx.setLineDash([]);
             }
        }
        
        this.drawSlingshot(ctx, true);
        this.particles.forEach(p => p.draw(ctx));

        ctx.restore();
    }

    drawClouds(ctx) {
        ctx.fillStyle = "rgba(255,255,255,0.6)";
        const t = Date.now() * 0.0005;
        for(let i=0; i<5; i++) {
            let x = ((i*200) + t*50) % (CONFIG.width*2) + this.cameraX*0.9;
            let y = 50 + i*30;
            ctx.beginPath();
            ctx.arc(x - this.cameraX, y, 40, 0, Math.PI*2);
            ctx.arc(x+30 - this.cameraX, y+10, 50, 0, Math.PI*2);
            ctx.fill();
        }
    }

    drawFlowers(ctx) {
        this.flowers.forEach(f => {
            if (f.x < this.cameraX - 50 || f.x > this.cameraX + CONFIG.width + 50) return;
            ctx.save();
            ctx.translate(f.x, f.y);
            ctx.scale(f.scale, f.scale);
            ctx.fillStyle = f.color;
            // Draw Paw Flower
            ctx.beginPath(); ctx.arc(0, -10, 8, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(-10, -15, 5, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(0, -22, 5, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(10, -15, 5, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = 'green'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0,-5); ctx.stroke();
            ctx.restore();
        });
    }

    drawSlingshot(ctx, front) {
        const x = this.slingX;
        const y = this.slingY;
        
        // Tech Style Colors
        const metalDark = '#2c3e50';
        const metalLight = '#95a5a6';
        const energyColor = this.launcherLevel > 5 ? '#f1c40f' : '#00d2ff'; // Gold or Cyan

        if (!front) {
            // Back Pillar (The base)
            ctx.save();
            const grad = ctx.createLinearGradient(x - 10, y, x + 10, y);
            grad.addColorStop(0, metalDark);
            grad.addColorStop(0.5, metalLight);
            grad.addColorStop(1, metalDark);
            
            ctx.fillStyle = grad;
            ctx.fillRect(x - 10, y, 20, 60); // Base post
            
            // Mechanical details
            ctx.fillStyle = '#34495e';
            ctx.fillRect(x - 12, y + 50, 24, 10); // Base plate
            ctx.restore();

            // Back Fork
            ctx.save();
            ctx.strokeStyle = metalDark;
            ctx.lineWidth = 8;
            ctx.lineCap = 'square';
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x - 25, y - 40);
            ctx.stroke();
            
            // Energy Node
            ctx.fillStyle = energyColor;
            ctx.shadowColor = energyColor;
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(x - 25, y - 40, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        } else {
            // Elastic (Energy Beam)
            if (this.state === 'AIM' && this.dragCurrent) {
                ctx.save();
                ctx.strokeStyle = energyColor; // Energy beam
                ctx.lineWidth = 4 + (this.launcherLevel * 0.5);
                ctx.shadowColor = energyColor;
                ctx.shadowBlur = 15;
                ctx.globalAlpha = 0.8;
                
                ctx.beginPath();
                ctx.moveTo(x - 25, y - 40);
                ctx.lineTo(this.dragCurrent.x, this.dragCurrent.y);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(x + 25, y - 40);
                ctx.lineTo(this.dragCurrent.x, this.dragCurrent.y);
                ctx.stroke();
                ctx.restore();
            }

            // Front Fork
            ctx.save();
            ctx.strokeStyle = metalDark;
            ctx.lineWidth = 8;
            ctx.lineCap = 'square';
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + 25, y - 40);
            ctx.stroke();

            // Energy Node
            ctx.fillStyle = energyColor;
            ctx.shadowColor = energyColor;
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(x + 25, y - 40, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
    }

    drawObstacle(ctx, ob) {
        if (ob.x < this.cameraX - 100 || ob.x > this.cameraX + CONFIG.width + 100) return;
        
        ctx.save();
        ctx.translate(ob.x + ob.w/2, ob.y + ob.h/2);
        ctx.rotate(ob.rotation);
        
        if (ob.hp < ob.maxHp) {
            ctx.rotate((Math.random()-0.5) * 0.05);
        }

        if (ob.type === 99) { // Cage
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 4;
            ctx.strokeRect(-ob.w/2, -ob.h/2, ob.w, ob.h);
            ctx.beginPath();
            ctx.moveTo(-10, -ob.h/2); ctx.lineTo(-10, ob.h/2);
            ctx.moveTo(10, -ob.h/2); ctx.lineTo(10, ob.h/2);
            ctx.stroke();
            if (this.state !== 'LEVEL_END') {
                 ctx.fillStyle = 'red';
                 ctx.font = '20px Arial';
                 ctx.fillText('ğŸ‘‘', -10, 5);
            }
        } 
        else if (ob.type === 9 || ob.type === 10) { // Can
            ctx.fillStyle = ob.getColor();
            ctx.beginPath();
            ctx.roundRect(-ob.w/2, -ob.h/2, ob.w, ob.h, 5);
            ctx.fill();
            ctx.strokeStyle = '#FBC02D';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = '#F57F17';
            ctx.font = (ob.type===10 ? '30px' : '20px') + ' Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const face = ob.hp < ob.maxHp/2 ? 'ğŸ™€' : 'ğŸ˜¼';
            ctx.fillText(face, 0, 0);
            
            ctx.fillStyle = ob.getColor();
            ctx.beginPath(); 
            ctx.moveTo(-ob.w/2, -ob.h/2); ctx.lineTo(-ob.w/2 + 5, -ob.h/2-10); ctx.lineTo(-ob.w/2 + 15, -ob.h/2); ctx.fill();
            ctx.beginPath(); 
            ctx.moveTo(ob.w/2, -ob.h/2); ctx.lineTo(ob.w/2 - 5, -ob.h/2-10); ctx.lineTo(ob.w/2 - 15, -ob.h/2); ctx.fill();

        } else { // Blocks
            ctx.fillStyle = ob.getColor();
            ctx.fillRect(-ob.w/2, -ob.h/2, ob.w, ob.h);
            ctx.strokeStyle = "rgba(0,0,0,0.2)";
            ctx.lineWidth = 2;
            ctx.strokeRect(-ob.w/2, -ob.h/2, ob.w, ob.h);
            
            if (ob.hp < ob.maxHp * 0.7) {
                ctx.beginPath(); ctx.moveTo(-10, -10); ctx.lineTo(10, 10); ctx.stroke();
            }
        }
        ctx.restore();
    }

    drawCat(ctx, cat) {
        const x = cat.x;
        const y = cat.y;
        const r = cat.radius || 15;
        
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(cat.rotation);
        
        // Fun Animation: Tail
        const tailAngle = Math.sin(this.gameFrame * 0.5) * 0.5;
        ctx.save();
        ctx.strokeStyle = cat.color;
        ctx.lineWidth = r/4; // Tail thickness scales with cat
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(-r + 5, 0);
        ctx.quadraticCurveTo(-r - 10, 0, -r - 15, tailAngle * 10);
        ctx.stroke();
        ctx.restore();

        // Body
        ctx.fillStyle = cat.color;
        ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#333'; ctx.lineWidth = 2; ctx.stroke();
        
        if(cat.pattern === 'cow') {
            ctx.fillStyle = '#333'; ctx.beginPath(); ctx.arc(-r/3, -r/3, r/2.5, 0, Math.PI*2); ctx.fill();
        } else if (cat.pattern === 'stripe') {
            ctx.beginPath(); ctx.moveTo(-r, -r/3); ctx.lineTo(r, -r/3); ctx.stroke();
        }

        const speed = Math.hypot(cat.vx || 0, cat.vy || 0);
        const isFlyingFast = speed > 5;

        ctx.fillStyle = '#FFF';
        if (isFlyingFast) {
            ctx.beginPath(); ctx.arc(-r/3, -r/5, r/4, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(r/3, -r/5, r/4, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#000';
            ctx.beginPath(); ctx.arc(-r/3, -r/5, r/10, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(r/3, -r/5, r/10, 0, Math.PI*2); ctx.fill();
        } else {
            ctx.beginPath(); ctx.arc(-r/3, -r/5, r/5, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(r/3, -r/5, r/5, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#000';
            ctx.beginPath(); ctx.arc(-r/3, -r/5, r/10, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(r/3, -r/5, r/10, 0, Math.PI*2); ctx.fill();
        }

        if (cat.skillUsed && this.state === 'FLY') {
             ctx.strokeStyle = 'yellow';
             ctx.globalAlpha = 0.5;
             ctx.lineWidth = 3;
             ctx.beginPath(); ctx.arc(0, 0, r+5, 0, Math.PI*2); ctx.stroke();
        }

        ctx.restore();
    }

    loop(t) {
        const dt = t - this.lastTime;
        this.lastTime = t;
        
        if (this.state !== 'MENU') {
            this.update(dt);
        }
        this.draw();
        requestAnimationFrame(tm => this.loop(tm));
    }
}

// Start
var game;
window.onload = () => {
    game = new Game();
};

</script>
</body>
</html>
